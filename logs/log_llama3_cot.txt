Event Description 1: 
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).

terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).

terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).

initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).

terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).

initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).

terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).

initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).

terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).

initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).

terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).

initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).

initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).

initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).

terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).

terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).

terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).

terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).

holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).

initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).

terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).

initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).

terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).

initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).

terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).

staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.

holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).

holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).

holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).

holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).

initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).

terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).

holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).

holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).

_dummy_rule :- 
	.

_dummy_rule :- 
	.

_dummy_rule :- 
	.

_dummy_rule :- 
	.

_dummy_rule :- 
	.

_dummy_rule :- 
	.

_dummy_rule :- 
	.

_dummy_rule :- 
	.

_dummy_rule :- 
	.

_dummy_rule :- 
	.

_dummy_rule :- 
	.

_dummy_rule :- 
	.

_dummy_rule :- 
	.

_dummy_rule :- 
	.


Event Description 2: 
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).



Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.0
Body atom distances: 
[[0. 1.]
 [1. 0.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
0.0
Distance between rule bodies: 
0.0
Distance between rules: 
0.0
Similarity of rules: 
1.0

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  0.5]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
0.5
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.7625000000000001
Similarity of rules: 
0.23749999999999993

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.   1.   1.   1.  ]
 [1.   1.   1.   1.   1.  ]
 [1.   1.   1.   1.   1.  ]
 [1.   1.   1.   1.   1.  ]
 [1.   1.   1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.25
Distance between rule bodies: 
0.85
Distance between rules: 
0.7291666666666666
Similarity of rules: 
0.27083333333333337

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.25
Distance between rule bodies: 
0.8125
Distance between rules: 
0.675
Similarity of rules: 
0.32499999999999996

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.25
Distance between rule bodies: 
0.8125
Distance between rules: 
0.675
Similarity of rules: 
0.32499999999999996

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5 1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
5.5
Distance between rule bodies: 
0.9166666666666666
Distance between rules: 
0.8303571428571428
Similarity of rules: 
0.1696428571428572

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.25
Distance between rule bodies: 
0.8125
Distance between rules: 
0.6625000000000001
Similarity of rules: 
0.3374999999999999

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5 1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.5
Distance between rule bodies: 
0.9
Distance between rules: 
0.8020833333333333
Similarity of rules: 
0.19791666666666674

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6041666666666666
Similarity of rules: 
0.39583333333333337

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  0.5]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
0.5
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.0
Body atom distances: 
[[0. 1.]
 [1. 0.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
0.0
Distance between rule bodies: 
0.0
Distance between rules: 
0.0
Similarity of rules: 
1.0

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.03125
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4270833333333333
Similarity of rules: 
0.5729166666666667

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4583333333333333
Similarity of rules: 
0.5416666666666667

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4583333333333333
Similarity of rules: 
0.5416666666666667

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4583333333333333
Similarity of rules: 
0.5416666666666667

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.5
Distance between rule bodies: 
0.9
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.59375
Similarity of rules: 
0.40625

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4583333333333333
Similarity of rules: 
0.5416666666666667

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
5.5
Distance between rule bodies: 
0.9166666666666666
Distance between rules: 
0.9285714285714285
Similarity of rules: 
0.07142857142857151

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.25
Distance between rule bodies: 
0.8125
Distance between rules: 
0.6625000000000001
Similarity of rules: 
0.3374999999999999

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.25
Distance between rule bodies: 
0.8125
Distance between rules: 
0.6625000000000001
Similarity of rules: 
0.3374999999999999

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.5
Distance between rule bodies: 
0.9
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.25
Distance between rule bodies: 
0.8125
Distance between rules: 
0.6625000000000001
Similarity of rules: 
0.3374999999999999

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,AreaID),T),
	areaType(AreaID,AreaType).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'AreaID': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.03125
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4270833333333333
Similarity of rules: 
0.5729166666666667

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0
Body atom distances: 
[[0.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.0
Distance between rule bodies: 
0.0
Distance between rules: 
0.0
Similarity of rules: 
1.0

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.375 1.   ]
 [1.    1.   ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.375
Distance between rule bodies: 
0.6875
Distance between rules: 
0.7916666666666666
Similarity of rules: 
0.20833333333333337

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.375 1.   ]
 [1.    1.   ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.375
Distance between rule bodies: 
0.6875
Distance between rules: 
0.7916666666666666
Similarity of rules: 
0.20833333333333337

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.1875
Similarity of rules: 
0.8125

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.1875
Similarity of rules: 
0.8125

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.1875
Similarity of rules: 
0.8125

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.5
Distance between rule bodies: 
0.5
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.15625
Similarity of rules: 
0.84375

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.15625
Similarity of rules: 
0.84375

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.5
Distance between rule bodies: 
0.5
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.15625
Similarity of rules: 
0.84375

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.15625
Similarity of rules: 
0.84375

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.15625
Similarity of rules: 
0.84375

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.5
Distance between rule bodies: 
0.9
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.59375
Similarity of rules: 
0.40625

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.1875
Similarity of rules: 
0.8125

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
5.5
Distance between rule bodies: 
0.9166666666666666
Distance between rules: 
0.9285714285714285
Similarity of rules: 
0.07142857142857151

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.25
Distance between rule bodies: 
0.8125
Distance between rules: 
0.6625000000000001
Similarity of rules: 
0.3374999999999999

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.15625
Similarity of rules: 
0.84375

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.15625
Similarity of rules: 
0.84375

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.25
Distance between rule bodies: 
0.8125
Distance between rules: 
0.6625000000000001
Similarity of rules: 
0.3374999999999999

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.15625
Similarity of rules: 
0.84375

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.5
Distance between rule bodies: 
0.9
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.25
Distance between rule bodies: 
0.8125
Distance between rules: 
0.6625000000000001
Similarity of rules: 
0.3374999999999999

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.15625
Similarity of rules: 
0.84375

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.15625
Similarity of rules: 
0.84375

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.15625
Similarity of rules: 
0.84375

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.15625
Similarity of rules: 
0.84375

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.5
Distance between rule bodies: 
0.5
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.5
Distance between rule bodies: 
0.5
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.15625
Similarity of rules: 
0.84375

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.375 1.   ]
 [1.    1.   ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.375
Distance between rule bodies: 
0.6875
Distance between rules: 
0.7916666666666666
Similarity of rules: 
0.20833333333333337

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.0
Body atom distances: 
[[0. 1.]
 [1. 0.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
0.0
Distance between rule bodies: 
0.0
Distance between rules: 
0.0
Similarity of rules: 
1.0

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.34375
Body atom distances: 
[[0.375 1.   ]
 [1.    1.   ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.375
Distance between rule bodies: 
0.6875
Distance between rules: 
0.5729166666666666
Similarity of rules: 
0.42708333333333337

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25     1.      ]
 [1.       0.015625]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
0.265625
Distance between rule bodies: 
0.1328125
Distance between rules: 
0.109375
Similarity of rules: 
0.890625

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25    1.      1.      1.     ]
 [1.      1.      1.      0.03125]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 3 1 2]
Sum of distances for optimal body condition assignment: 
2.28125
Distance between rule bodies: 
0.5703125
Distance between rules: 
0.48125
Similarity of rules: 
0.51875

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.5
Distance between rule bodies: 
0.9
Distance between rules: 
0.8125
Similarity of rules: 
0.1875

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.775
Similarity of rules: 
0.22499999999999998

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.775
Similarity of rules: 
0.22499999999999998

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25   1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     0.0625]
 [1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 5 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.3125
Distance between rule bodies: 
0.71875
Distance between rules: 
0.6339285714285714
Similarity of rules: 
0.3660714285714286

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.775
Similarity of rules: 
0.22499999999999998

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25    1.      1.      1.      1.     ]
 [1.      1.      1.      1.      0.03125]
 [1.      1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 4 1 2 3]
Sum of distances for optimal body condition assignment: 
3.28125
Distance between rule bodies: 
0.65625
Distance between rules: 
0.5677083333333333
Similarity of rules: 
0.43229166666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25    1.     ]
 [1.      0.03125]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
0.28125
Distance between rule bodies: 
0.140625
Distance between rules: 
0.13541666666666666
Similarity of rules: 
0.8645833333333334

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.71875
Similarity of rules: 
0.28125

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.375 1.   ]
 [1.    1.   ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.375
Distance between rule bodies: 
0.6875
Distance between rules: 
0.7916666666666666
Similarity of rules: 
0.20833333333333337

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.34375
Body atom distances: 
[[0.375 1.   ]
 [1.    1.   ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.375
Distance between rule bodies: 
0.6875
Distance between rules: 
0.5729166666666666
Similarity of rules: 
0.42708333333333337

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.0
Body atom distances: 
[[0. 1.]
 [1. 0.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
0.0
Distance between rule bodies: 
0.0
Distance between rules: 
0.0
Similarity of rules: 
1.0

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25      1.       ]
 [1.        0.0078125]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
0.2578125
Distance between rule bodies: 
0.12890625
Distance between rules: 
0.10677083333333333
Similarity of rules: 
0.8932291666666666

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  0.5 1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 2 1 3]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
0.75
Distance between rules: 
0.675
Similarity of rules: 
0.32499999999999996

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.5
Distance between rule bodies: 
0.9
Distance between rules: 
0.8125
Similarity of rules: 
0.1875

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.775
Similarity of rules: 
0.22499999999999998

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.775
Similarity of rules: 
0.22499999999999998

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  0.5]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 2 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
0.6666666666666666
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
5.5
Distance between rule bodies: 
0.9166666666666666
Distance between rules: 
0.8392857142857142
Similarity of rules: 
0.1607142857142858

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.775
Similarity of rules: 
0.22499999999999998

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  0.5]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 3 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
0.75
Distance between rules: 
0.8
Similarity of rules: 
0.19999999999999996

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  0.5 0.5 1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 2 1 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  0.5 0.5 1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
17.5
Distance between rule bodies: 
0.9722222222222222
Distance between rules: 
0.9736842105263157
Similarity of rules: 
0.026315789473684292

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.5
Distance between rule bodies: 
0.9
Distance between rules: 
0.8125
Similarity of rules: 
0.1875

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  0.5]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 3 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
0.75
Distance between rules: 
0.8
Similarity of rules: 
0.19999999999999996

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.71875
Similarity of rules: 
0.28125

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4583333333333333
Similarity of rules: 
0.5416666666666667

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.1875
Similarity of rules: 
0.8125

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0
Body atom distances: 
[[0.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.0
Distance between rule bodies: 
0.0
Distance between rules: 
0.0
Similarity of rules: 
1.0

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.15625
Similarity of rules: 
0.84375

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.15625
Similarity of rules: 
0.84375

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.5
Distance between rule bodies: 
0.5
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.1875
Similarity of rules: 
0.8125

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.1875
Similarity of rules: 
0.8125

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.5
Distance between rule bodies: 
0.5
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.1875
Similarity of rules: 
0.8125

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.1875
Similarity of rules: 
0.8125

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.59375
Similarity of rules: 
0.40625

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.1875
Similarity of rules: 
0.8125

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.5
Distance between rule bodies: 
0.9
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.15625
Similarity of rules: 
0.84375

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
5.5
Distance between rule bodies: 
0.9166666666666666
Distance between rules: 
0.9285714285714285
Similarity of rules: 
0.07142857142857151

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.25
Distance between rule bodies: 
0.8125
Distance between rules: 
0.675
Similarity of rules: 
0.32499999999999996

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.1875
Similarity of rules: 
0.8125

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.1875
Similarity of rules: 
0.8125

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.25
Distance between rule bodies: 
0.8125
Distance between rules: 
0.675
Similarity of rules: 
0.32499999999999996

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.1875
Similarity of rules: 
0.8125

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.5
Distance between rule bodies: 
0.9
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.25
Distance between rule bodies: 
0.8125
Distance between rules: 
0.675
Similarity of rules: 
0.32499999999999996

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.1875
Similarity of rules: 
0.8125

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.1875
Similarity of rules: 
0.8125

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.1875
Similarity of rules: 
0.8125

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.59375
Similarity of rules: 
0.40625

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.1875
Similarity of rules: 
0.8125

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.5
Distance between rule bodies: 
0.5
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.5
Distance between rule bodies: 
0.5
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
0.25
Distance between rule bodies: 
0.25
Distance between rules: 
0.1875
Similarity of rules: 
0.8125

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(gap(Vessel),_Value),T) :- 
	happensAt(gap_end(Vessel),T).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.8
Similarity of rules: 
0.19999999999999996

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.5
Distance between rule bodies: 
0.9
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.8
Similarity of rules: 
0.19999999999999996

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.8
Similarity of rules: 
0.19999999999999996

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
5.5
Distance between rule bodies: 
0.9166666666666666
Distance between rules: 
0.8571428571428571
Similarity of rules: 
0.1428571428571429

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  0.5]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 3 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
0.75
Distance between rules: 
0.8
Similarity of rules: 
0.19999999999999996

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.8
Similarity of rules: 
0.19999999999999996

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.5
Distance between rule bodies: 
0.9
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(stopped(Vessel),I) :- 
	happensAt(presentIn(Vessel,Position),It),
	=<(speedOverGround(Vessel,Position),thresholdLowSpeed),
	not_holdsFor(>(speedOverGround(Vessel,Position),thresholdLowSpeed),It).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('presentIn', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Position': [[('happensAt', 0), ('presentIn', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]], 'It': [[('happensAt', 1)], [('not_holdsFor', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.5
Distance between rule bodies: 
0.9
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  0.5 1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 4 1 2 3 5]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.8571428571428571
Similarity of rules: 
0.1428571428571429

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.8
Similarity of rules: 
0.19999999999999996

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.8
Similarity of rules: 
0.19999999999999996

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.5
Distance between rule bodies: 
0.9
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.8
Similarity of rules: 
0.19999999999999996

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(stopped(Vessel),T) :- 
	happensAt(not_presentIn(Vessel,Position),Ta),
	>(speedOverGround(Vessel,Position),thresholdLowSpeed).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('stopped', 0)], [('happensAt', 0), ('not_presentIn', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Position': [[('happensAt', 0), ('not_presentIn', 1)], [('>', 0), ('speedOverGround', 1)]], 'Ta': [[('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9285714285714285
Similarity of rules: 
0.07142857142857151

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1. ]
 [1.  1.  1.  0.5]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 3 1 2]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(lowSpeed(Vessel),I) :- 
	exists(Message,in(recentMessages,Message)),
	=<(speedOverGround(Vessel,Message),vmin),
	all(Message,in(recentMessages,Message),=<(speedOverGround(Vessel,Message),vmin)).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('lowSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 2), ('=<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('in', 1)], [('=<', 0), ('speedOverGround', 1)], [('all', 0)], [('all', 1), ('in', 1)], [('all', 2), ('=<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  0.5 1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 4 1 2 3 5]
Sum of distances for optimal body condition assignment: 
5.5
Distance between rule bodies: 
0.9166666666666666
Distance between rules: 
0.9285714285714285
Similarity of rules: 
0.07142857142857151

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(lowSpeed(Vessel),T) :- 
	exists(Message,not_in(recentMessages,Message)),
	>(speedOverGround(Vessel,Message),vmin).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('lowSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'Message': [[('exists', 0)], [('exists', 1), ('not_in', 1)], [('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.8
Similarity of rules: 
0.19999999999999996

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.5
Distance between rule bodies: 
0.9
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.8
Similarity of rules: 
0.19999999999999996

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.8
Similarity of rules: 
0.19999999999999996

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  0.5 1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 4 1 2 3 5]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.7857142857142857
Similarity of rules: 
0.2142857142857143

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.8
Similarity of rules: 
0.19999999999999996

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.5
Distance between rule bodies: 
0.9
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(changingSpeed(Vessel),I) :- 
	happensAt(speedOverGround(Vessel,Position),vnow),
	>(abs(-(vnow,vprev)),alpha),
	not_holdsFor(=<(abs(-(vnow,vprev)),alpha),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.5
Distance between rule bodies: 
0.9
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
5.5
Distance between rule bodies: 
0.9166666666666666
Distance between rules: 
0.9285714285714285
Similarity of rules: 
0.07142857142857151

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  0.5]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 3 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
0.75
Distance between rules: 
0.7000000000000001
Similarity of rules: 
0.29999999999999993

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.8
Similarity of rules: 
0.19999999999999996

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.5
Distance between rule bodies: 
0.9
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.8
Similarity of rules: 
0.19999999999999996

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6666666666666666
Similarity of rules: 
0.33333333333333337

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(changingSpeed(Vessel),T) :- 
	happensAt(speedOverGround(Vessel,NewPosition),vnew),
	=<(abs(-(vnew,vnow)),alpha).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('changingSpeed', 0)], [('happensAt', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('happensAt', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.7625000000000001
Similarity of rules: 
0.23749999999999993

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.   1.   1.   1.  ]
 [1.   1.   1.   1.   1.  ]
 [1.   1.   1.   1.   1.  ]
 [1.   1.   1.   1.   1.  ]
 [1.   1.   1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.25
Distance between rule bodies: 
0.85
Distance between rules: 
0.7291666666666666
Similarity of rules: 
0.27083333333333337

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.25
Distance between rule bodies: 
0.8125
Distance between rules: 
0.675
Similarity of rules: 
0.32499999999999996

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.25
Distance between rule bodies: 
0.8125
Distance between rules: 
0.675
Similarity of rules: 
0.32499999999999996

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5 1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  0.5 1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 4 1 2 3 5]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.7589285714285714
Similarity of rules: 
0.2410714285714286

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.25
Distance between rule bodies: 
0.8125
Distance between rules: 
0.6625000000000001
Similarity of rules: 
0.3374999999999999

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5 1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.5
Distance between rule bodies: 
0.9
Distance between rules: 
0.8020833333333333
Similarity of rules: 
0.19791666666666674

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6041666666666666
Similarity of rules: 
0.39583333333333337

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(enterArea(Vessel,nearCoast),T),
	>(highSpeed(Vessel),highSpeedLimit).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('enterArea', 0)], [('>', 0), ('highSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4583333333333333
Similarity of rules: 
0.5416666666666667

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4583333333333333
Similarity of rules: 
0.5416666666666667

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4583333333333333
Similarity of rules: 
0.5416666666666667

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.5
Distance between rule bodies: 
0.9
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.59375
Similarity of rules: 
0.40625

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4583333333333333
Similarity of rules: 
0.5416666666666667

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
5.5
Distance between rule bodies: 
0.9166666666666666
Distance between rules: 
0.9285714285714285
Similarity of rules: 
0.07142857142857151

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.25
Distance between rule bodies: 
0.8125
Distance between rules: 
0.6625000000000001
Similarity of rules: 
0.3374999999999999

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.25
Distance between rule bodies: 
0.8125
Distance between rules: 
0.6625000000000001
Similarity of rules: 
0.3374999999999999

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.5
Distance between rule bodies: 
0.9
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]
 [1.   1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.25
Distance between rule bodies: 
0.8125
Distance between rules: 
0.6625000000000001
Similarity of rules: 
0.3374999999999999

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(highSpeed(Vessel),true),T) :- 
	happensAt(exitArea(Vessel,nearCoast),T),
	<(highSpeed(Vessel),lowSpeedLimit).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeed', 0)], [('happensAt', 0), ('exitArea', 0)], [('<', 0), ('highSpeed', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9285714285714285
Similarity of rules: 
0.07142857142857151

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  0.5]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[3 0 1 2]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"below"),I) :- 
	=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),
	not_holdsFor(>(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9285714285714285
Similarity of rules: 
0.07142857142857151

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1. ]
 [1.  1.  1.  0.5]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 3 1 2]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"normal"),I) :- 
	>=(speedOverGround(Vessel,Position),minServiceSpeed),
	=<(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minServiceSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9285714285714285
Similarity of rules: 
0.07142857142857151

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(movingSpeed(Vessel,"above"),I) :- 
	>=(speedOverGround(Vessel,Position),maxServiceSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),maxServiceSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('movingSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  0.5 1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[4 0 1 2 3 5]
Sum of distances for optimal body condition assignment: 
5.5
Distance between rule bodies: 
0.9166666666666666
Distance between rules: 
0.9285714285714285
Similarity of rules: 
0.07142857142857151

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"below"),T) :- 
	>(speedOverGround(Vessel,NewPosition),*(minServiceSpeed,0.5)).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	<(speedOverGround(Vessel,NewPosition),minServiceSpeed).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  0.5 1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[4 0 1 2 3 5]
Sum of distances for optimal body condition assignment: 
5.5
Distance between rule bodies: 
0.9166666666666666
Distance between rules: 
0.9285714285714285
Similarity of rules: 
0.07142857142857151

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"normal"),T) :- 
	>(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(movingSpeed(Vessel,"above"),T) :- 
	<(speedOverGround(Vessel,NewPosition),maxServiceSpeed).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('movingSpeed', 0)], [('<', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('<', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9736842105263157
Similarity of rules: 
0.026315789473684292

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9444444444444444
Similarity of rules: 
0.05555555555555558

Comparing rules:
 holdsFor(underway(Vessel),T) :- 
	or(=<(speedOverGround(Vessel,Position),*(minServiceSpeed,0.5)),>=(speedOverGround(Vessel,Position),minServiceSpeed),=<(speedOverGround(Vessel,Position),maxServiceSpeed),>=(speedOverGround(Vessel,Position),maxServiceSpeed)),
	all(previouslyObserved(-(I,timeStep)),-(underway(Vessel)),=(I,T)).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('underway', 0)], [('or', 0), ('=<', 0), ('speedOverGround', 0)], [('or', 1), ('>=', 0), ('speedOverGround', 0)], [('or', 2), ('=<', 0), ('speedOverGround', 0)], [('or', 3), ('>=', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('underway', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'Position': [[('or', 0), ('=<', 0), ('speedOverGround', 1)], [('or', 1), ('>=', 0), ('speedOverGround', 1)], [('or', 2), ('=<', 0), ('speedOverGround', 1)], [('or', 3), ('>=', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9642857142857142
Similarity of rules: 
0.03571428571428581

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.34375 1.      1.      1.     ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.34375
Distance between rule bodies: 
0.8359375
Distance between rules: 
0.7312500000000001
Similarity of rules: 
0.26874999999999993

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.34375 1.      1.     ]
 [1.      1.      1.     ]
 [1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.34375
Distance between rule bodies: 
0.78125
Distance between rules: 
0.8359375
Similarity of rules: 
0.1640625

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.09375 1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.09375
Distance between rule bodies: 
0.81875
Distance between rules: 
0.703125
Similarity of rules: 
0.296875

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.09375 1.      1.      1.     ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.09375
Distance between rule bodies: 
0.7734375
Distance between rules: 
0.64375
Similarity of rules: 
0.35624999999999996

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.09375 1.      1.      1.     ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.09375
Distance between rule bodies: 
0.7734375
Distance between rules: 
0.64375
Similarity of rules: 
0.35624999999999996

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.34375 1.      1.     ]
 [1.      1.      1.     ]
 [1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.34375
Distance between rule bodies: 
0.78125
Distance between rules: 
0.8359375
Similarity of rules: 
0.1640625

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
0.28125
Body atom distances: 
[[0.375 1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    0.5   1.   ]
 [1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.   ]]
Optimal Body Condition Assignment: 
[0 4 1 2 3 5]
Sum of distances for optimal body condition assignment: 
4.875
Distance between rule bodies: 
0.8125
Distance between rules: 
0.7366071428571428
Similarity of rules: 
0.2633928571428572

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.375 1.    1.    1.   ]
 [1.    1.    1.    1.   ]
 [1.    1.    1.    1.   ]
 [1.    1.    1.    1.   ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.375
Distance between rule bodies: 
0.84375
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.34375 1.     ]
 [1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.34375
Distance between rule bodies: 
0.671875
Distance between rules: 
0.78125
Similarity of rules: 
0.21875

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.09375 1.      1.      1.     ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.09375
Distance between rule bodies: 
0.7734375
Distance between rules: 
0.6312500000000001
Similarity of rules: 
0.3687499999999999

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.34375 1.      1.      1.     ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.34375
Distance between rule bodies: 
0.8359375
Distance between rules: 
0.86875
Similarity of rules: 
0.13124999999999998

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.34375 1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.34375
Distance between rule bodies: 
0.86875
Distance between rules: 
0.7760416666666666
Similarity of rules: 
0.22395833333333337

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.34375 1.      1.      1.     ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.34375
Distance between rule bodies: 
0.8359375
Distance between rules: 
0.86875
Similarity of rules: 
0.13124999999999998

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.6041666666666666
Similarity of rules: 
0.39583333333333337

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.09375 1.      1.     ]
 [1.      1.      1.     ]
 [1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.09375
Distance between rule bodies: 
0.6979166666666666
Distance between rules: 
0.5390625
Similarity of rules: 
0.4609375

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.34375 1.      1.     ]
 [1.      1.      1.     ]
 [1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.34375
Distance between rule bodies: 
0.78125
Distance between rules: 
0.8359375
Similarity of rules: 
0.1640625

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	>(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('>', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4583333333333333
Similarity of rules: 
0.5416666666666667

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4583333333333333
Similarity of rules: 
0.5416666666666667

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4583333333333333
Similarity of rules: 
0.5416666666666667

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.34375 1.      1.      1.     ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.34375
Distance between rule bodies: 
0.8359375
Distance between rules: 
0.86875
Similarity of rules: 
0.13124999999999998

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.09375 1.      1.     ]
 [1.      1.      1.     ]
 [1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.09375
Distance between rule bodies: 
0.6979166666666666
Distance between rules: 
0.5390625
Similarity of rules: 
0.4609375

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.34375 1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.34375
Distance between rule bodies: 
0.86875
Distance between rules: 
0.890625
Similarity of rules: 
0.109375

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.34375 1.      1.      1.     ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.34375
Distance between rule bodies: 
0.8359375
Distance between rules: 
0.86875
Similarity of rules: 
0.13124999999999998

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.34375 1.      1.      1.     ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.34375
Distance between rule bodies: 
0.8359375
Distance between rules: 
0.86875
Similarity of rules: 
0.13124999999999998

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.09375 1.      1.     ]
 [1.      1.      1.     ]
 [1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.09375
Distance between rule bodies: 
0.6979166666666666
Distance between rules: 
0.5546875
Similarity of rules: 
0.4453125

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4583333333333333
Similarity of rules: 
0.5416666666666667

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.375 1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.   ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
5.375
Distance between rule bodies: 
0.8958333333333334
Distance between rules: 
0.9107142857142857
Similarity of rules: 
0.0892857142857143

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
0.0
Body atom distances: 
[[0.09375 1.      1.      1.     ]
 [1.      1.      1.      0.5    ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 3 1 2]
Sum of distances for optimal body condition assignment: 
2.59375
Distance between rule bodies: 
0.6484375
Distance between rules: 
0.51875
Similarity of rules: 
0.48124999999999996

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0
Body atom distances: 
[[0.0625 1.    ]
 [1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.0625
Distance between rule bodies: 
0.53125
Distance between rules: 
0.35416666666666663
Similarity of rules: 
0.6458333333333334

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.03125
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4270833333333333
Similarity of rules: 
0.5729166666666667

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.34375 1.      1.      1.     ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.34375
Distance between rule bodies: 
0.8359375
Distance between rules: 
0.86875
Similarity of rules: 
0.13124999999999998

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.09375 1.      1.      1.     ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.09375
Distance between rule bodies: 
0.7734375
Distance between rules: 
0.6312500000000001
Similarity of rules: 
0.3687499999999999

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.34375 1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.34375
Distance between rule bodies: 
0.86875
Distance between rules: 
0.890625
Similarity of rules: 
0.109375

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.09375 1.      1.      1.     ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]
 [1.      1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.09375
Distance between rule bodies: 
0.7734375
Distance between rules: 
0.6312500000000001
Similarity of rules: 
0.3687499999999999

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.34375 1.      1.     ]
 [1.      1.      1.     ]
 [1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.34375
Distance between rule bodies: 
0.78125
Distance between rules: 
0.8359375
Similarity of rules: 
0.1640625

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.09375 1.      1.     ]
 [1.      1.      1.     ]
 [1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.09375
Distance between rule bodies: 
0.6979166666666666
Distance between rules: 
0.5390625
Similarity of rules: 
0.4609375

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1. ]
 [1.  1. ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.5
Distance between rule bodies: 
0.75
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.  ]
 [1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
1.25
Distance between rule bodies: 
0.625
Distance between rules: 
0.4375
Similarity of rules: 
0.5625

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,CoG,_CoG,TrueHeading),T),
	=<(abs(diff(CoG,TrueHeading)),driftThreshold).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CoG': [[('happensAt', 0), ('velocity', 1)], [('=<', 0), ('abs', 0), ('diff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9285714285714285
Similarity of rules: 
0.07142857142857151

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1. ]
 [1.  1.  1.  0.5]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 3 1 2]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(trawlSpeed(Vessel),I) :- 
	>=(speedOverGround(Vessel,Position),minTrawlSpeed),
	=<(speedOverGround(Vessel,Position),maxTrawlSpeed),
	not_holdsFor(<(speedOverGround(Vessel,Position),minTrawlSpeed),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,Position),maxTrawlSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('trawlSpeed', 0)], [('>=', 0), ('speedOverGround', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'Position': [[('>=', 0), ('speedOverGround', 1)], [('=<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('<', 0), ('speedOverGround', 1)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(trawlSpeed(Vessel),T) :- 
	or(<(speedOverGround(Vessel,NewPosition),minTrawlSpeed),>(speedOverGround(Vessel,NewPosition),maxTrawlSpeed)).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('trawlSpeed', 0)], [('or', 0), ('<', 0), ('speedOverGround', 0)], [('or', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'NewPosition': [[('or', 0), ('<', 0), ('speedOverGround', 1)], [('or', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.71875
Similarity of rules: 
0.28125

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.71875
Similarity of rules: 
0.28125

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.71875
Similarity of rules: 
0.28125

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.375
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.71875
Similarity of rules: 
0.28125

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.3125 1.     1.     1.    ]
 [1.     1.     1.     1.    ]
 [1.     1.     1.     1.    ]
 [1.     1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.3125
Distance between rule bodies: 
0.828125
Distance between rules: 
0.7250000000000001
Similarity of rules: 
0.2749999999999999

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.3125 1.     1.    ]
 [1.     1.     1.    ]
 [1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.3125
Distance between rule bodies: 
0.7708333333333334
Distance between rules: 
0.828125
Similarity of rules: 
0.171875

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.0625 1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.0625
Distance between rule bodies: 
0.8125
Distance between rules: 
0.6979166666666666
Similarity of rules: 
0.30208333333333337

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.0625 1.     1.     1.    ]
 [1.     1.     1.     1.    ]
 [1.     1.     1.     1.    ]
 [1.     1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.0625
Distance between rule bodies: 
0.765625
Distance between rules: 
0.6375000000000001
Similarity of rules: 
0.36249999999999993

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.0625 1.     1.     1.    ]
 [1.     1.     1.     1.    ]
 [1.     1.     1.     1.    ]
 [1.     1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.0625
Distance between rule bodies: 
0.765625
Distance between rules: 
0.6375000000000001
Similarity of rules: 
0.36249999999999993

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.3125 1.     1.    ]
 [1.     1.     1.    ]
 [1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.3125
Distance between rule bodies: 
0.7708333333333334
Distance between rules: 
0.828125
Similarity of rules: 
0.171875

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.375 1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    0.5   1.   ]
 [1.    1.    1.    1.    0.5   1.   ]
 [1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.   ]]
Optimal Body Condition Assignment: 
[0 4 1 2 3 5]
Sum of distances for optimal body condition assignment: 
4.875
Distance between rule bodies: 
0.8125
Distance between rules: 
0.7410714285714285
Similarity of rules: 
0.2589285714285715

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.375 1.    1.    1.   ]
 [1.    1.    1.    1.   ]
 [1.    1.    1.    1.   ]
 [1.    1.    1.    1.   ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.375
Distance between rule bodies: 
0.84375
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.34375 1.      1.     ]
 [1.      1.      1.     ]
 [1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.34375
Distance between rule bodies: 
0.78125
Distance between rules: 
0.8359375
Similarity of rules: 
0.1640625

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.0625 1.     1.     1.    ]
 [1.     1.     1.     1.    ]
 [1.     1.     1.     1.    ]
 [1.     1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.0625
Distance between rule bodies: 
0.765625
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.3125 1.     1.     1.    ]
 [1.     1.     1.     1.    ]
 [1.     1.     1.     1.    ]
 [1.     1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.3125
Distance between rule bodies: 
0.828125
Distance between rules: 
0.8625
Similarity of rules: 
0.13749999999999996

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.3125 1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.3125
Distance between rule bodies: 
0.8625
Distance between rules: 
0.7708333333333333
Similarity of rules: 
0.22916666666666674

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.3125 1.     1.     1.    ]
 [1.     1.     1.     1.    ]
 [1.     1.     1.     1.    ]
 [1.     1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.3125
Distance between rule bodies: 
0.828125
Distance between rules: 
0.8625
Similarity of rules: 
0.13749999999999996

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.703125
Similarity of rules: 
0.296875

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.0625 1.     1.    ]
 [1.     1.     1.    ]
 [1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.0625
Distance between rule bodies: 
0.6875
Distance between rules: 
0.53125
Similarity of rules: 
0.46875

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.3125 1.     1.    ]
 [1.     1.     1.    ]
 [1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.3125
Distance between rule bodies: 
0.7708333333333334
Distance between rules: 
0.828125
Similarity of rules: 
0.171875

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	>(Speed,trawlingThresholdSpeed),
	>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('>', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.59375
Similarity of rules: 
0.40625

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.59375
Similarity of rules: 
0.40625

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.59375
Similarity of rules: 
0.40625

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.3125 1.     1.     1.    ]
 [1.     1.     1.     1.    ]
 [1.     1.     1.     1.    ]
 [1.     1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.3125
Distance between rule bodies: 
0.828125
Distance between rules: 
0.8625
Similarity of rules: 
0.13749999999999996

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.0625 1.     1.    ]
 [1.     1.     1.    ]
 [1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.0625
Distance between rule bodies: 
0.6875
Distance between rules: 
0.53125
Similarity of rules: 
0.46875

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.3125 1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.3125
Distance between rule bodies: 
0.8625
Distance between rules: 
0.8854166666666666
Similarity of rules: 
0.11458333333333337

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.3125 1.     1.     1.    ]
 [1.     1.     1.     1.    ]
 [1.     1.     1.     1.    ]
 [1.     1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.3125
Distance between rule bodies: 
0.828125
Distance between rules: 
0.8625
Similarity of rules: 
0.13749999999999996

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.3125 1.     1.     1.    ]
 [1.     1.     1.     1.    ]
 [1.     1.     1.     1.    ]
 [1.     1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.3125
Distance between rule bodies: 
0.828125
Distance between rules: 
0.8625
Similarity of rules: 
0.13749999999999996

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.0625 1.     1.    ]
 [1.     1.     1.    ]
 [1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.0625
Distance between rule bodies: 
0.6875
Distance between rules: 
0.546875
Similarity of rules: 
0.453125

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.125
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.59375
Similarity of rules: 
0.40625

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.375 1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.   ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
5.375
Distance between rule bodies: 
0.8958333333333334
Distance between rules: 
0.9107142857142857
Similarity of rules: 
0.0892857142857143

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.125 1.    1.    1.   ]
 [1.    1.    1.    0.5  ]
 [1.    1.    1.    0.5  ]
 [1.    1.    1.    1.   ]]
Optimal Body Condition Assignment: 
[0 3 1 2]
Sum of distances for optimal body condition assignment: 
2.625
Distance between rule bodies: 
0.65625
Distance between rules: 
0.5375
Similarity of rules: 
0.4625

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.09375 1.      1.     ]
 [1.      1.      1.     ]
 [1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.09375
Distance between rule bodies: 
0.6979166666666666
Distance between rules: 
0.5390625
Similarity of rules: 
0.4609375

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.3125 1.     1.     1.    ]
 [1.     1.     1.     1.    ]
 [1.     1.     1.     1.    ]
 [1.     1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.3125
Distance between rule bodies: 
0.828125
Distance between rules: 
0.8625
Similarity of rules: 
0.13749999999999996

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.0625 1.     1.     1.    ]
 [1.     1.     1.     1.    ]
 [1.     1.     1.     1.    ]
 [1.     1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.0625
Distance between rule bodies: 
0.765625
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.3125 1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.3125
Distance between rule bodies: 
0.8625
Distance between rules: 
0.8854166666666666
Similarity of rules: 
0.11458333333333337

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.0625 1.     1.     1.    ]
 [1.     1.     1.     1.    ]
 [1.     1.     1.     1.    ]
 [1.     1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
3.0625
Distance between rule bodies: 
0.765625
Distance between rules: 
0.625
Similarity of rules: 
0.375

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.3125 1.     1.    ]
 [1.     1.     1.    ]
 [1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.3125
Distance between rule bodies: 
0.7708333333333334
Distance between rules: 
0.828125
Similarity of rules: 
0.171875

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.0625 1.     1.    ]
 [1.     1.     1.    ]
 [1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.0625
Distance between rule bodies: 
0.6875
Distance between rules: 
0.53125
Similarity of rules: 
0.46875

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[0.5 1.  1. ]
 [1.  1.  1. ]
 [1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.5
Distance between rule bodies: 
0.8333333333333334
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25 1.   1.  ]
 [1.   1.   1.  ]
 [1.   1.   1.  ]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
2.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.578125
Similarity of rules: 
0.421875

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(=(trawling(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,CoG,TrueHeading),T),
	=<(Speed,trawlingThresholdSpeed),
	=<(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawling', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('=<', 0)]], 'CoG': [[('happensAt', 0), ('velocity', 2)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)]], 'MaxHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('=<', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 staticallyDetermined(=(trawling(Vessel),holdsFor(comma(vesselType(Vessel,fishing),exists(MaxHeadingAngle,MinHeadingAngle),>(abs(diff(MaxHeadingAngle,MinHeadingAngle)),trawlingThresholdHeadingAngle))))) :- 
	_.
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('staticallyDetermined', 0), ('=', 0), ('trawling', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 0), ('vesselType', 0)]], 'MaxHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 0)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 0)]], 'MinHeadingAngle': [[('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 1), ('exists', 1)], [('staticallyDetermined', 0), ('=', 1), ('holdsFor', 0), ('comma', 2), ('>', 0), ('abs', 0), ('diff', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.375 0.375 0.375 1.    1.    1.    1.   ]
 [0.375 0.375 0.375 1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.    1.   ]
 [0.375 0.125 0.375 1.    1.    1.    1.   ]
 [1.    1.    1.    0.5   1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.    1.   ]]
Optimal Body Condition Assignment: 
[0 2 4 1 3 5 6]
Sum of distances for optimal body condition assignment: 
4.375
Distance between rule bodies: 
0.625
Distance between rules: 
0.5859375
Similarity of rules: 
0.4140625

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.0
Body atom distances: 
[[0.         0.375      1.         0.3125     1.         1.
  1.        ]
 [0.375      0.         1.         0.375      1.         1.
  1.        ]
 [1.         1.         0.         1.         1.         1.
  1.        ]
 [0.3125     0.375      1.         0.         1.         1.
  1.        ]
 [1.         1.         1.         1.         0.         1.
  1.        ]
 [1.         1.         1.         1.         1.         1.
  1.        ]
 [1.         1.         1.         1.         1.         1.
  0.16666667]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
1.1666666666666667
Distance between rule bodies: 
0.16666666666666669
Distance between rules: 
0.14583333333333334
Similarity of rules: 
0.8541666666666666

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.125      1.         1.         1.         0.375      0.375
  1.         1.         1.        ]
 [0.3125     1.         1.         1.         0.0625     0.3125
  1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  0.5        1.         1.        ]
 [0.375      1.         1.         1.         0.375      0.375
  1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         0.33333333]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.        ]]
Optimal Body Condition Assignment: 
[0 4 6 5 1 2 8 3 7]
Sum of distances for optimal body condition assignment: 
5.395833333333333
Distance between rule bodies: 
0.599537037037037
Distance between rules: 
0.5458333333333333
Similarity of rules: 
0.4541666666666667

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.375      1.         1.         0.375      0.375      0.28125
  0.28125    1.         1.         1.         1.         0.375
  0.375      0.375      0.375      1.         1.         1.        ]
 [0.3125     1.         1.         0.3125     0.3125     0.375
  0.375      1.         1.         1.         1.         0.28125
  0.28125    0.28125    0.28125    1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         0.5        1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [0.375      1.         1.         0.375      0.375      0.09375
  0.09375    1.         1.         1.         1.         0.375
  0.375      0.375      0.375      1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         0.3125     0.3125     1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         0.33333333]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]]
Optimal Body Condition Assignment: 
[ 5 11  9  6  7  0 17  1  2  3  4  8 10 12 13 14 15 16]
Sum of distances for optimal body condition assignment: 
13.802083333333332
Distance between rule bodies: 
0.7667824074074073
Distance between rules: 
0.7297149122807016
Similarity of rules: 
0.2702850877192984

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.125      0.375      1.         1.         1.         1.
  1.        ]
 [0.3125     0.0625     1.         1.         1.         1.
  1.        ]
 [1.         1.         0.25       1.         1.         1.
  1.        ]
 [0.375      0.375      1.         1.         1.         1.
  1.        ]
 [1.         1.         1.         1.         1.         1.
  1.        ]
 [1.         1.         1.         1.         1.         1.
  1.        ]
 [1.         1.         1.         1.         0.33333333 1.
  1.        ]]
Optimal Body Condition Assignment: 
[0 1 2 3 6 5 4]
Sum of distances for optimal body condition assignment: 
3.7708333333333335
Distance between rule bodies: 
0.5386904761904762
Distance between rules: 
0.47916666666666663
Similarity of rules: 
0.5208333333333334

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.125      0.375      1.         1.         1.         1.
  1.        ]
 [0.3125     0.0625     1.         1.         1.         1.
  1.        ]
 [1.         1.         0.25       1.         1.         1.
  1.        ]
 [0.375      0.375      1.         1.         1.         1.
  1.        ]
 [1.         1.         1.         1.         1.         1.
  1.        ]
 [1.         1.         1.         1.         1.         1.
  1.        ]
 [1.         1.         1.         0.33333333 1.         1.
  1.        ]]
Optimal Body Condition Assignment: 
[0 1 2 6 4 5 3]
Sum of distances for optimal body condition assignment: 
3.7708333333333335
Distance between rule bodies: 
0.5386904761904762
Distance between rules: 
0.47916666666666663
Similarity of rules: 
0.5208333333333334

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.375      0.28125    1.         0.375      0.375      1.
  1.         1.        ]
 [0.3125     0.375      1.         0.28125    0.3125     1.
  1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.        ]
 [0.375      0.09375    1.         0.375      0.375      1.
  1.         1.        ]
 [1.         1.         0.3125     1.         1.         1.
  1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         0.33333333]
 [1.         1.         1.         1.         1.         1.
  1.         1.        ]]
Optimal Body Condition Assignment: 
[4 3 0 1 2 5 7 6]
Sum of distances for optimal body condition assignment: 
4.395833333333333
Distance between rule bodies: 
0.5494791666666666
Distance between rules: 
0.4953703703703703
Similarity of rules: 
0.5046296296296298

Comparing rules:
 holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Isffp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Iwa),
	intersect_all(list(Isffp,Iwa),Isa),
	holdsFor(=(stopped(Vessel),nearPorts),Isn),
	union_all(list(Isa,Isn),Ii),
	threshold(vaorm,Vaorm),
	intDurGreater(Ii,Vaorm,I).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Isffp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Iwa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isn': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'Vaorm': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.375   1.      0.375   0.375   0.28125 0.28125 1.      1.      1.
  1.      0.375   0.375   1.     ]
 [0.3125  1.      0.3125  0.3125  0.375   0.375   1.      1.      1.
  1.      0.28125 0.28125 1.     ]
 [1.      1.      1.      1.      1.      1.      1.      1.      0.5
  1.      1.      1.      1.     ]
 [0.375   1.      0.375   0.375   0.09375 0.09375 1.      1.      1.
  1.      0.375   0.375   1.     ]
 [1.      1.      1.      1.      1.      1.      0.3125  0.3125  1.
  1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.      1.      1.      1.      1.
  1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.      1.      1.      1.      1.
  1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.      1.      1.      1.      1.
  1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.      1.      1.      1.      1.
  1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.      1.      1.      1.      1.
  1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.      1.      1.      1.      1.
  1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.      1.      1.      1.      1.
  1.      1.      1.      1.     ]
 [1.      1.      1.      1.      1.      1.      1.      1.      1.
  1.      1.      1.      1.     ]]
Optimal Body Condition Assignment: 
[ 4 10  8  5  6  0  1  2  3  7  9 11 12]
Sum of distances for optimal body condition assignment: 
9.46875
Distance between rule bodies: 
0.7283653846153846
Distance between rules: 
0.6986607142857143
Similarity of rules: 
0.3013392857142857

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5   0.5   0.5   1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.    1.   ]
 [0.375 0.375 0.375 1.    1.    1.    1.   ]
 [0.375 0.375 0.375 1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.    1.   ]]
Optimal Body Condition Assignment: 
[0 4 3 2 1 5 6]
Sum of distances for optimal body condition assignment: 
5.25
Distance between rule bodies: 
0.75
Distance between rules: 
0.6953125
Similarity of rules: 
0.3046875

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25       0.5        1.         0.5        1.         1.
  1.        ]
 [1.         1.         1.         1.         1.         1.
  1.        ]
 [1.         1.         0.3125     1.         1.         1.
  1.        ]
 [0.375      0.3125     1.         0.375      1.         1.
  1.        ]
 [0.375      0.3125     1.         0.375      1.         1.
  1.        ]
 [1.         1.         1.         1.         1.         1.
  1.        ]
 [1.         1.         1.         1.         1.         1.
  0.33333333]]
Optimal Body Condition Assignment: 
[0 4 2 1 3 5 6]
Sum of distances for optimal body condition assignment: 
3.5833333333333335
Distance between rule bodies: 
0.511904761904762
Distance between rules: 
0.45572916666666674
Similarity of rules: 
0.5442708333333333

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25       1.         1.         1.         0.5        0.5
  1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  0.5        1.         1.        ]
 [0.3125     1.         1.         1.         0.3125     0.3125
  1.         1.         1.        ]
 [0.3125     1.         1.         1.         0.3125     0.3125
  1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         0.33333333]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.        ]]
Optimal Body Condition Assignment: 
[0 1 6 4 5 2 8 3 7]
Sum of distances for optimal body condition assignment: 
5.708333333333333
Distance between rule bodies: 
0.6342592592592592
Distance between rules: 
0.5770833333333333
Similarity of rules: 
0.4229166666666667

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.5        1.         1.         0.5        0.5        0.5
  0.5        1.         1.         1.         1.         0.5
  0.5        0.5        0.5        1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         0.5        1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [0.3125     1.         1.         0.3125     0.3125     0.375
  0.375      1.         1.         1.         1.         0.3125
  0.3125     0.3125     0.3125     1.         1.         1.        ]
 [0.3125     1.         1.         0.3125     0.3125     0.375
  0.375      1.         1.         1.         1.         0.3125
  0.3125     0.3125     0.3125     1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         0.33333333]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.
  1.         1.         1.         1.         1.         1.        ]]
Optimal Body Condition Assignment: 
[ 0  1  9  3  4  2 17  5  6  7  8 10 11 12 13 14 15 16]
Sum of distances for optimal body condition assignment: 
14.958333333333332
Distance between rule bodies: 
0.8310185185185185
Distance between rules: 
0.7905701754385964
Similarity of rules: 
0.20942982456140358

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25       0.5        1.         1.         1.         1.
  1.        ]
 [1.         1.         1.         1.         1.         1.
  1.        ]
 [1.         1.         0.3125     1.         1.         1.
  1.        ]
 [0.3125     0.3125     1.         1.         1.         1.
  1.        ]
 [0.3125     0.3125     1.         1.         1.         1.
  1.        ]
 [1.         1.         1.         1.         1.         1.
  1.        ]
 [1.         1.         1.         1.         0.33333333 1.
  1.        ]]
Optimal Body Condition Assignment: 
[0 3 2 1 6 5 4]
Sum of distances for optimal body condition assignment: 
4.208333333333333
Distance between rule bodies: 
0.6011904761904762
Distance between rules: 
0.5338541666666666
Similarity of rules: 
0.46614583333333337

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
6.5
Distance between rule bodies: 
0.9285714285714286
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.25       0.5        1.         1.         1.         1.
  1.        ]
 [1.         1.         1.         1.         1.         1.
  1.        ]
 [1.         1.         0.3125     1.         1.         1.
  1.        ]
 [0.3125     0.3125     1.         1.         1.         1.
  1.        ]
 [0.3125     0.3125     1.         1.         1.         1.
  1.        ]
 [1.         1.         1.         1.         1.         1.
  1.        ]
 [1.         1.         1.         0.33333333 1.         1.
  1.        ]]
Optimal Body Condition Assignment: 
[0 6 2 1 4 5 3]
Sum of distances for optimal body condition assignment: 
4.208333333333333
Distance between rule bodies: 
0.6011904761904762
Distance between rules: 
0.5338541666666666
Similarity of rules: 
0.46614583333333337

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.0625
Body atom distances: 
[[0.5        0.5        1.         0.5        0.5        1.
  1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.        ]
 [0.3125     0.375      1.         0.3125     0.3125     1.
  1.         1.        ]
 [0.3125     0.375      1.         0.3125     0.3125     1.
  1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         1.        ]
 [1.         1.         1.         1.         1.         1.
  1.         0.33333333]
 [1.         1.         1.         1.         1.         1.
  1.         1.        ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 7 6]
Sum of distances for optimal body condition assignment: 
5.458333333333333
Distance between rule bodies: 
0.6822916666666666
Distance between rules: 
0.6134259259259258
Similarity of rules: 
0.3865740740740742

Comparing rules:
 holdsFor(=(tugging(Vessel),true),I) :- 
	holdsFor(notMovingByItself(Vessel),It),
	happensAt(association(Vessel,Tugboat),Itc),
	intersect_all(list(It,Itc),Isa),
	holdsFor(=(closeToEachOther(Vessel,Tugboat),true),Isa),
	holdsFor(=(lowerThanNormalSpeed(Vessel),true),Isa),
	threshold(vtug,Vtug),
	intDurGreater(Isa,Vtug,I).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('notMovingByItself', 0)], [('happensAt', 0), ('association', 0)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 0)], [('holdsFor', 0), ('=', 0), ('lowerThanNormalSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Tugboat': [[('happensAt', 0), ('association', 1)], [('holdsFor', 0), ('=', 0), ('closeToEachOther', 1)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Isa': [[('intersect_all', 1)], [('holdsFor', 1)], [('holdsFor', 1)], [('intDurGreater', 0)]], 'Vtug': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5    1.     0.5    0.5    0.5    0.5    1.     1.     1.     1.
  0.5    0.5    1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     0.5    1.
  1.     1.     1.    ]
 [0.3125 1.     0.3125 0.3125 0.375  0.375  1.     1.     1.     1.
  0.3125 0.3125 1.    ]
 [0.3125 1.     0.3125 0.3125 0.375  0.375  1.     1.     1.     1.
  0.3125 0.3125 1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[ 0  1  8  2  3  4  5  6  7  9 10 11 12]
Sum of distances for optimal body condition assignment: 
10.625
Distance between rule bodies: 
0.8173076923076923
Distance between rules: 
0.78125
Similarity of rules: 
0.21875

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5   0.5   0.5   1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.    1.    1.    1.   ]
 [0.375 0.375 0.375 1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    0.5   1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.    1.    1.    1.   ]]
Optimal Body Condition Assignment: 
[0 1 6 2 4 5 3 7 8]
Sum of distances for optimal body condition assignment: 
7.375
Distance between rule bodies: 
0.8194444444444444
Distance between rules: 
0.76875
Similarity of rules: 
0.23124999999999996

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5    0.5    1.     0.5    1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.    ]
 [0.375  0.3125 1.     0.375  1.     1.     1.     1.     1.    ]
 [1.     1.     0.125  1.     1.     1.     1.     1.     1.    ]
 [1.     1.     0.375  1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     0.3125 1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     0.5    1.     1.    ]]
Optimal Body Condition Assignment: 
[0 3 8 1 2 5 4 7 6]
Sum of distances for optimal body condition assignment: 
5.75
Distance between rule bodies: 
0.6388888888888888
Distance between rules: 
0.6062500000000001
Similarity of rules: 
0.39374999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5    1.     1.     1.     0.5    0.5    1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.    ]
 [0.3125 1.     1.     1.     0.3125 0.3125 1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     0.5    1.     1.    ]
 [1.     1.     1.     1.     1.     1.     0.5    1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     0.5   ]]
Optimal Body Condition Assignment: 
[0 1 2 4 6 3 5 7 8]
Sum of distances for optimal body condition assignment: 
6.8125
Distance between rule bodies: 
0.7569444444444444
Distance between rules: 
0.7125
Similarity of rules: 
0.2875

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5    1.     1.     0.5    0.5    0.5    0.5    1.     1.     1.
  1.     0.5    0.5    0.5    0.5    1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [0.3125 1.     1.     0.3125 0.3125 0.375  0.375  1.     1.     1.
  1.     0.3125 0.3125 0.3125 0.3125 1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     0.5
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     0.5
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     0.375  0.375  1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     0.5   ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  9  4  7  5 17  6  8 10 11 12 13 14 15 16]
Sum of distances for optimal body condition assignment: 
15.1875
Distance between rule bodies: 
0.84375
Distance between rules: 
0.8157894736842105
Similarity of rules: 
0.1842105263157895

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5    0.5    1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.    ]
 [0.3125 0.3125 1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     0.375  1.     1.     1.     1.     1.     1.    ]
 [1.     1.     0.375  1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     0.5    1.     1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 3 8 1 2 5 6 7 4]
Sum of distances for optimal body condition assignment: 
6.6875
Distance between rule bodies: 
0.7430555555555556
Distance between rules: 
0.7000000000000001
Similarity of rules: 
0.29999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [0.5 1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[1 0 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
8.5
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5    0.5    1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.    ]
 [0.3125 0.3125 1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     0.375  1.     1.     1.     1.     1.     1.    ]
 [1.     1.     0.375  1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     0.5    1.     1.     1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 8 4 1 2 5 6 7 3]
Sum of distances for optimal body condition assignment: 
6.6875
Distance between rule bodies: 
0.7430555555555556
Distance between rules: 
0.7000000000000001
Similarity of rules: 
0.29999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5    0.5    1.     0.5    0.5    1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.    ]
 [0.3125 0.375  1.     0.3125 0.3125 1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     0.375  1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     0.5    1.    ]]
Optimal Body Condition Assignment: 
[0 1 6 3 4 5 2 8 7]
Sum of distances for optimal body condition assignment: 
6.6875
Distance between rule bodies: 
0.7430555555555556
Distance between rules: 
0.7000000000000001
Similarity of rules: 
0.29999999999999993

Comparing rules:
 holdsFor(=(piloting(Vessel),true),I) :- 
	holdsFor(highlyExperiencedSailor(MaritimePilot),It),
	happensAt(approaches(PilotBoat,Vessel),Itc),
	happensAt(boards(MaritimePilot,Vessel),Ib),
	holdsFor(=(manoeuvres(Vessel,MaritimePilot),true),Ia),
	intersect_all(list(It,Itc),Isa),
	intersect_all(list(It,Ib),Isb),
	union_all(list(Isa,Isb),I),
	threshold(vpil,Vpil),
	intDurGreater(I,Vpil,I).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('piloting', 0)], [('happensAt', 0), ('approaches', 1)], [('happensAt', 0), ('boards', 1)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'MaritimePilot': [[('holdsFor', 0), ('highlyExperiencedSailor', 0)], [('happensAt', 0), ('boards', 0)], [('holdsFor', 0), ('=', 0), ('manoeuvres', 1)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 0), ('list', 0)]], 'PilotBoat': [[('happensAt', 0), ('approaches', 0)]], 'Itc': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ib': [[('happensAt', 1)], [('intersect_all', 0), ('list', 1)]], 'Ia': [[('holdsFor', 1)]], 'Isa': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Isb': [[('intersect_all', 1)], [('union_all', 0), ('list', 1)]], 'Vpil': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5    1.     0.5    0.5    0.5    0.5    1.     1.     1.     1.
  0.5    0.5    1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.    ]
 [0.3125 1.     0.3125 0.3125 0.375  0.375  1.     1.     1.     1.
  0.3125 0.3125 1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     0.5    1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     0.5    1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     0.375  0.375  1.     1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  8  4  6  5  7  9 10 11 12]
Sum of distances for optimal body condition assignment: 
10.6875
Distance between rule bodies: 
0.8221153846153846
Distance between rules: 
0.7857142857142857
Similarity of rules: 
0.2142857142857143

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5   0.5   0.5   1.    1.    1.    1.    1.   ]
 [0.375 0.375 0.375 1.    1.    1.    1.    1.   ]
 [0.375 0.375 0.375 1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    0.375 1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.    1.    1.   ]
 [1.    1.    1.    1.    1.    1.    1.    1.   ]]
Optimal Body Condition Assignment: 
[0 1 2 5 4 3 6 7]
Sum of distances for optimal body condition assignment: 
5.625
Distance between rule bodies: 
0.703125
Distance between rules: 
0.6597222222222222
Similarity of rules: 
0.3402777777777778

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5    0.5    1.     0.5    1.     1.     1.     1.    ]
 [0.375  0.3125 1.     0.375  1.     1.     1.     1.    ]
 [0.375  0.3125 1.     0.375  1.     1.     1.     1.    ]
 [1.     1.     0.375  1.     1.     1.     1.     1.    ]
 [1.     1.     0.375  1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     0.5    1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     0.5    1.    ]]
Optimal Body Condition Assignment: 
[0 1 3 2 5 4 7 6]
Sum of distances for optimal body condition assignment: 
4.5625
Distance between rule bodies: 
0.5703125
Distance between rules: 
0.5416666666666666
Similarity of rules: 
0.45833333333333337

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5    1.     1.     1.     0.5    0.5    1.     1.     1.    ]
 [0.3125 1.     1.     1.     0.3125 0.3125 1.     1.     1.    ]
 [0.3125 1.     1.     1.     0.3125 0.3125 1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     0.5    1.     1.    ]
 [1.     1.     1.     1.     1.     1.     0.5    1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     0.5   ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[0 4 5 6 1 2 3 8 7]
Sum of distances for optimal body condition assignment: 
6.125
Distance between rule bodies: 
0.6805555555555556
Distance between rules: 
0.64375
Similarity of rules: 
0.35624999999999996

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.28125
Body atom distances: 
[[0.5    1.     1.     0.5    0.5    0.5    0.5    1.     1.     1.
  1.     0.5    0.5    0.5    0.5    1.     1.     1.    ]
 [0.3125 1.     1.     0.3125 0.3125 0.375  0.375  1.     1.     1.
  1.     0.3125 0.3125 0.3125 0.3125 1.     1.     1.    ]
 [0.3125 1.     1.     0.3125 0.3125 0.375  0.375  1.     1.     1.
  1.     0.3125 0.3125 0.3125 0.3125 1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     0.5
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     0.5
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     0.5    0.5    1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     0.5   ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.     1.     1.     1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[ 0  3  4  9  1  7  2 17  5  6  8 10 11 12 13 14 15 16]
Sum of distances for optimal body condition assignment: 
14.625
Distance between rule bodies: 
0.8125
Distance between rules: 
0.7845394736842105
Similarity of rules: 
0.2154605263157895

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5    0.5    1.     1.     1.     1.     1.     1.    ]
 [0.3125 0.3125 1.     1.     1.     1.     1.     1.    ]
 [0.3125 0.3125 1.     1.     1.     1.     1.     1.    ]
 [1.     1.     0.375  1.     1.     1.     1.     1.    ]
 [1.     1.     0.375  1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     0.5    1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[3 1 0 2 7 5 6 4]
Sum of distances for optimal body condition assignment: 
5.5
Distance between rule bodies: 
0.6875
Distance between rules: 
0.6458333333333333
Similarity of rules: 
0.35416666666666674

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5    0.5    1.     1.     1.     1.     1.     1.    ]
 [0.3125 0.3125 1.     1.     1.     1.     1.     1.    ]
 [0.3125 0.3125 1.     1.     1.     1.     1.     1.    ]
 [1.     1.     0.375  1.     1.     1.     1.     1.    ]
 [1.     1.     0.375  1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     0.5    1.     1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[7 1 0 2 4 5 6 3]
Sum of distances for optimal body condition assignment: 
5.5
Distance between rule bodies: 
0.6875
Distance between rules: 
0.6458333333333333
Similarity of rules: 
0.35416666666666674

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5    0.5    1.     0.5    0.5    1.     1.     1.    ]
 [0.3125 0.375  1.     0.3125 0.3125 1.     1.     1.    ]
 [0.3125 0.375  1.     0.3125 0.3125 1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     0.5    1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     0.5   ]]
Optimal Body Condition Assignment: 
[0 3 4 1 5 2 6 7]
Sum of distances for optimal body condition assignment: 
5.125
Distance between rule bodies: 
0.640625
Distance between rules: 
0.6041666666666666
Similarity of rules: 
0.39583333333333337

Comparing rules:
 holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(nearbyInOpenSea(Vessel1,Vessel2),Isa),
	holdsFor(=(stoppedOrLowSpeed(Vessel1),true),Isf),
	holdsFor(=(stoppedOrLowSpeed(Vessel2),true),Isb),
	intersect_all(list(Isa,Isf),Isa),
	intersect_all(list(Isa,Isb),Isb),
	union_all(list(Isa,Isf,Isb),I),
	threshold(vrendez,Vrendez),
	intDurGreater(I,Vrendez,I).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('nearbyInOpenSea', 0)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('nearbyInOpenSea', 1)], [('holdsFor', 0), ('=', 0), ('stoppedOrLowSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'Isa': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)], [('intersect_all', 1)], [('intersect_all', 0), ('list', 0)], [('union_all', 0), ('list', 0)]], 'Isf': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('union_all', 0), ('list', 1)]], 'Isb': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)], [('intersect_all', 1)], [('union_all', 0), ('list', 2)]], 'Vrendez': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5    1.     0.5    0.5    0.5    0.5    1.     1.     1.     1.
  0.5    0.5    1.    ]
 [0.3125 1.     0.3125 0.3125 0.375  0.375  1.     1.     1.     1.
  0.3125 0.3125 1.    ]
 [0.3125 1.     0.3125 0.3125 0.375  0.375  1.     1.     1.     1.
  0.3125 0.3125 1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     0.5    1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     0.5    1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     0.5    0.5    1.     1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.    ]
 [1.     1.     1.     1.     1.     1.     1.     1.     1.     1.
  1.     1.     1.    ]]
Optimal Body Condition Assignment: 
[ 0  2  3  8  1  6  4  5  7  9 10 11 12]
Sum of distances for optimal body condition assignment: 
10.125
Distance between rule bodies: 
0.7788461538461539
Distance between rules: 
0.7455357142857142
Similarity of rules: 
0.2544642857142858

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9285714285714285
Similarity of rules: 
0.07142857142857151

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1. ]
 [1.  1.  1.  0.5]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 3 1 2]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 initiatedAt(sarResult(Vessel),I) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	not_holdsFor(<(absHeadingDifference(Vessel,NewPreviousHeading),headingChangeThreshold),previouslyObserved(-(I,timeStep))),
	not_holdsFor(>(speedOverGround(Vessel,NewPosition),minSARSpeed),previouslyObserved(-(I,timeStep))).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('initiatedAt', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 0)], [('not_holdsFor', 0), ('>', 0), ('speedOverGround', 0)]], 'I': [[('initiatedAt', 1)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)], [('not_holdsFor', 1), ('previouslyObserved', 0), ('-', 0)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'NewPreviousHeading': [[('not_holdsFor', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('not_holdsFor', 0), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.8333333333333333
Similarity of rules: 
0.16666666666666674

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.875
Similarity of rules: 
0.125

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.75
Similarity of rules: 
0.25

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 terminatedAt(sarResult(Vessel),T) :- 
	and(<(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),>(speedOverGround(Vessel,NewPosition),minSARSpeed)).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('terminatedAt', 0), ('sarResult', 0)], [('and', 0), ('<', 0), ('absHeadingDifference', 0)], [('and', 1), ('>', 0), ('speedOverGround', 0)]], 'T': [[('terminatedAt', 1)]], 'PreviousHeading': [[('and', 0), ('<', 0), ('absHeadingDifference', 1)]], 'NewPosition': [[('and', 1), ('>', 0), ('speedOverGround', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.  1.  1.  1. ]
 [1.  1.  1.  0.5]
 [1.  1.  1.  1. ]
 [1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 3 1 2]
Sum of distances for optimal body condition assignment: 
3.5
Distance between rule bodies: 
0.875
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9375
Similarity of rules: 
0.0625

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9500000000000001
Similarity of rules: 
0.04999999999999993

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9736842105263157
Similarity of rules: 
0.026315789473684292

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9166666666666666
Similarity of rules: 
0.08333333333333337

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9
Similarity of rules: 
0.09999999999999998

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9444444444444444
Similarity of rules: 
0.05555555555555558

Comparing rules:
 holdsFor(sarResult(Vessel),T) :- 
	>=(absHeadingDifference(Vessel,PreviousHeading),headingChangeThreshold),
	=<(speedOverGround(Vessel,Position),minSARSpeed),
	all(previouslyObserved(-(I,timeStep)),-(sarResult(Vessel)),=(I,T)).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('sarResult', 0)], [('>=', 0), ('absHeadingDifference', 0)], [('=<', 0), ('speedOverGround', 0)], [('all', 1), ('-', 0), ('sarResult', 0)]], 'T': [[('holdsFor', 1)], [('all', 2), ('=', 1)]], 'PreviousHeading': [[('>=', 0), ('absHeadingDifference', 1)]], 'Position': [[('=<', 0), ('speedOverGround', 1)]], 'I': [[('all', 0), ('previouslyObserved', 0), ('-', 0)], [('all', 2), ('=', 0)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
0.5
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
0.9642857142857142
Similarity of rules: 
0.03571428571428581

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5 0.5 0.5 1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
4.5
Distance between rule bodies: 
0.9
Distance between rules: 
0.8020833333333333
Similarity of rules: 
0.19791666666666674

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5 0.5 1.  0.5 1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  0.5]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  0.5]
 [1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 6 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
0.8571428571428571
Distance between rules: 
0.7890625
Similarity of rules: 
0.2109375

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5 1.  1.  1.  0.5 0.5 1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  0.5]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  0.5]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 8 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
0.8888888888888888
Distance between rules: 
0.83125
Similarity of rules: 
0.16874999999999996

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5 1.  1.  0.5 0.5 0.5 0.5 1.  1.  1.  1.  0.5 0.5 0.5 0.5 1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  0.5]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  0.5]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[ 0 17  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16]
Sum of distances for optimal body condition assignment: 
17.0
Distance between rule bodies: 
0.9444444444444444
Distance between rules: 
0.9111842105263157
Similarity of rules: 
0.08881578947368429

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5 0.5 1.  1.  1. ]
 [1.  1.  1.  1.  0.5]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  0.5]]
Optimal Body Condition Assignment: 
[0 4 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
0.8
Distance between rules: 
0.71875
Similarity of rules: 
0.28125

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5 0.5 1.  1.  1. ]
 [1.  1.  1.  0.5 1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1. ]
 [1.  1.  1.  0.5 1. ]]
Optimal Body Condition Assignment: 
[0 3 1 2 4]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
0.8
Distance between rules: 
0.71875
Similarity of rules: 
0.28125

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
0.28125
Body atom distances: 
[[0.5 0.5 1.  0.5 0.5 1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  0.5]
 [1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  0.5]
 [1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[0 7 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
0.875
Distance between rules: 
0.8090277777777777
Similarity of rules: 
0.19097222222222232

Comparing rules:
 holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(presentIn(Vessel,ParticularArea),Isa),
	intDurGreater(Isa,Vlong,I),
	not_holdsFor(evidentPurpose(Vessel),Isa),
	threshold(vloiter,Vloiter),
	intDurGreater(I,Vloiter,I).
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('presentIn', 0)], [('not_holdsFor', 0), ('evidentPurpose', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)], [('intDurGreater', 0)], [('intDurGreater', 2)]], 'ParticularArea': [[('holdsFor', 0), ('presentIn', 1)]], 'Isa': [[('holdsFor', 1)], [('intDurGreater', 0)], [('not_holdsFor', 1)]], 'Vlong': [[('intDurGreater', 1)]], 'Vloiter': [[('threshold', 1)], [('intDurGreater', 1)]]}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
0.3125
Body atom distances: 
[[0.5 1.  0.5 0.5 0.5 0.5 1.  1.  1.  1.  0.5 0.5 1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]
 [1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1.  1. ]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
12.5
Distance between rule bodies: 
0.9615384615384616
Distance between rules: 
0.9151785714285714
Similarity of rules: 
0.0848214285714286

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(entersArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('entersArea', 0)]], 'AreaType': [[('initiatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('entersArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,AreaType),true),T) :- 
	happensAt(leavesArea(Vessel,Area),T),
	areaType(Area,AreaType).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('leavesArea', 0)]], 'AreaType': [[('terminatedAt', 0), ('=', 0), ('withinArea', 1)], [('areaType', 1)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Area': [[('happensAt', 0), ('leavesArea', 1)], [('areaType', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(withinArea(Vessel,_AreaType),true),T) :- 
	happensAt(gap_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('withinArea', 0)], [('happensAt', 0), ('gap_start', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),nearPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(gap(Vessel),farFromPorts),T) :- 
	happensAt(gap_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(gap(Vessel),_PortStatus),T) :- 
	happensAt(gap_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('gap', 0)], [('happensAt', 0), ('gap_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),nearPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	holdsAt(=(withinArea(Vessel,nearPorts),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(stopped(Vessel),farFromPorts),T) :- 
	happensAt(stop_start(Vessel),T),
	-(holdsAt(=(withinArea(Vessel,nearPorts),true),T)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_start', 0)], [('-', 0), ('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('-', 0), ('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(stop_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('stop_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(stopped(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('stopped', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(slow_motion_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('slow_motion_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(lowSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('lowSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_start(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_start', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(change_in_speed_end(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('change_in_speed_end', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(changingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('changingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	-(inRange(Speed,0,HcNearCoastMax)),
	holdsAt(=(withinArea(Vessel,nearCoast),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(hcNearCoastMax,HcNearCoastMax),
	inRange(Speed,0,HcNearCoastMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'HcNearCoastMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(highSpeedNearCoast(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,nearCoast),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('highSpeedNearCoast', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),below),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,_Max,_Avg),
	thresholds(movingMin,MovingMin),
	inRange(Speed,MovingMin,Min).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 2)]], 'MovingMin': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),normal),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,Min,Max,_Avg),
	inRange(Speed,Min,Max).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Min': [[('typeSpeed', 1)], [('inRange', 1)]], 'Max': [[('typeSpeed', 2)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(movingSpeed(Vessel),above),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	vesselType(Vessel,Type),
	typeSpeed(Type,_Min,Max,_Avg),
	inRange(Speed,Max,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('vesselType', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'Type': [[('vesselType', 1)], [('typeSpeed', 0)]], 'Max': [[('typeSpeed', 2)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(movingMin,MovingMin),
	-(inRange(Speed,MovingMin,inf)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'MovingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(movingSpeed(Vessel),_Status),T) :- 
	happensAt(start(=(gap(Vessel),_GapStatus)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('movingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(underWay(Vessel),true),I) :- 
	holdsFor(=(movingSpeed(Vessel),below),I1),
	holdsFor(=(movingSpeed(Vessel),normal),I2),
	holdsFor(=(movingSpeed(Vessel),above),I3),
	union_all(list(I1,I2,I3),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('underWay', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)], [('holdsFor', 0), ('=', 0), ('movingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('union_all', 1)]], 'I1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'I2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I3': [[('holdsFor', 1)], [('union_all', 0), ('list', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	=\=(TrueHeading,511.0),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	>(AngleDiff,AdriftAngThr),
	holdsAt(=(underWay(Vessel),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('underWay', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('=\\=', 0)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('>', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('>', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5]
Sum of distances for optimal body condition assignment: 
6.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,CourseOverGround,TrueHeading),T),
	absoluteAngleDiff(CourseOverGround,TrueHeading,AngleDiff),
	thresholds(adriftAngThr,AdriftAngThr),
	=<(AngleDiff,AdriftAngThr).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'CourseOverGround': [[('happensAt', 0), ('velocity', 2)], [('absoluteAngleDiff', 0)]], 'TrueHeading': [[('happensAt', 0), ('velocity', 3)], [('absoluteAngleDiff', 1)]], 'AngleDiff': [[('absoluteAngleDiff', 2)], [('=<', 0)]], 'AdriftAngThr': [[('thresholds', 1)], [('=<', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(velocity(Vessel,_Speed,_CourseOverGround,511.0),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(drifting(Vessel),true),T) :- 
	happensAt(end(=(underWay(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('drifting', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('underWay', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(anchoredOrMoored(Vessel),true),I) :- 
	holdsFor(=(stopped(Vessel),farFromPorts),Istfp),
	holdsFor(=(withinArea(Vessel,anchorage),true),Ia),
	intersect_all(list(Istfp,Ia),Ista),
	holdsFor(=(stopped(Vessel),nearPorts),Istnp),
	union_all(list(Ista,Istnp),Ii),
	thresholds(aOrMTime,AOrMTime),
	intDurGreater(Ii,AOrMTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Istfp': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Ia': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ista': [[('intersect_all', 1)], [('union_all', 0), ('list', 0)]], 'Istnp': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ii': [[('union_all', 1)], [('intDurGreater', 0)]], 'AOrMTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6]
Sum of distances for optimal body condition assignment: 
7.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	inRange(Speed,TuggingMin,TuggingMax).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(tuggingMin,TuggingMin),
	thresholds(tuggingMax,TuggingMax),
	-(inRange(Speed,TuggingMin,TuggingMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TuggingMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TuggingMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(tuggingSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('tuggingSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(tugging(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsTug(Vessel1,Vessel2),
	-(oneIsPilot(Vessel1,Vessel2)),
	-(twoAreTugs(Vessel1,Vessel2)),
	holdsFor(=(tuggingSpeed(Vessel1),true),Its1),
	holdsFor(=(tuggingSpeed(Vessel2),true),Its2),
	intersect_all(list(Ip,Its1,Its2),Ii),
	thresholds(tuggingTime,TuggingTime),
	intDurGreater(Ii,TuggingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('tugging', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('-', 0), ('twoAreTugs', 0)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('tugging', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('-', 0), ('twoAreTugs', 1)], [('holdsFor', 0), ('=', 0), ('tuggingSpeed', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Its1': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Its2': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TuggingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7 8]
Sum of distances for optimal body condition assignment: 
9.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(rendezVous(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	-(oneIsTug(Vessel1,Vessel2)),
	-(oneIsPilot(Vessel1,Vessel2)),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),If),
	\=(If,list),
	holdsFor(=(withinArea(Vessel1,nearPorts),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearPorts),true),Iw2),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw3),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw4),
	relative_complement_all(If,list(Iw1,Iw2,Iw3,Iw4),Ii),
	thresholds(rendezvousTime,RendezvousTime),
	intDurGreater(Ii,RendezvousTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('rendezVous', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('-', 0), ('oneIsTug', 0)], [('-', 0), ('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('rendezVous', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('-', 0), ('oneIsTug', 1)], [('-', 0), ('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'If': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Iw3': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 2)]], 'Iw4': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 3)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'RendezvousTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Sum of distances for optimal body condition assignment: 
18.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	inRange(Speed,TrawlspeedMin,TrawlspeedMax),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_Heading,_),T),
	thresholds(trawlspeedMin,TrawlspeedMin),
	thresholds(trawlspeedMax,TrawlspeedMax),
	-(inRange(Speed,TrawlspeedMin,TrawlspeedMax)).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('-', 0), ('inRange', 0)]], 'TrawlspeedMin': [[('thresholds', 1)], [('-', 0), ('inRange', 1)]], 'TrawlspeedMax': [[('thresholds', 1)], [('-', 0), ('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlSpeed(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlSpeed', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T),
	holdsAt(=(withinArea(Vessel,fishing),true),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)], [('holdsAt', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)], [('holdsAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1.]
 [1. 1.]]
Optimal Body Condition Assignment: 
[0 1]
Sum of distances for optimal body condition assignment: 
2.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(trawlingMovement(Vessel),true),T) :- 
	happensAt(end(=(withinArea(Vessel,fishing),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('trawlingMovement', 0)], [('happensAt', 0), ('end', 0), ('=', 0), ('withinArea', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(trawling(Vessel),true),I) :- 
	holdsFor(=(trawlSpeed(Vessel),true),It),
	holdsFor(=(trawlingMovement(Vessel),true),Itc),
	intersect_all(list(It,Itc),Ii),
	thresholds(trawlingTime,TrawlingTime),
	intDurGreater(Ii,TrawlingTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('trawling', 0)], [('holdsFor', 0), ('=', 0), ('trawlSpeed', 0)], [('holdsFor', 0), ('=', 0), ('trawlingMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'It': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Itc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]], 'TrawlingTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4]
Sum of distances for optimal body condition assignment: 
5.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,SarMinSpeed,inf).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(velocity(Vessel,Speed,_,_),T),
	thresholds(sarMinSpeed,SarMinSpeed),
	inRange(Speed,0,SarMinSpeed).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('velocity', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]], 'Speed': [[('happensAt', 0), ('velocity', 1)], [('inRange', 0)]], 'SarMinSpeed': [[('thresholds', 1)], [('inRange', 2)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2]
Sum of distances for optimal body condition assignment: 
3.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarSpeed(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarSpeed', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(change_in_heading(Vessel),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('change_in_heading', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
initiatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(changingSpeed(Vessel),true)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('initiatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('changingSpeed', 0)]], 'T': [[('initiatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
terminatedAt(=(sarMovement(Vessel),true),T) :- 
	happensAt(start(=(gap(Vessel),_Status)),T).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('terminatedAt', 0), ('=', 0), ('sarMovement', 0)], [('happensAt', 0), ('start', 0), ('=', 0), ('gap', 0)]], 'T': [[('terminatedAt', 1)], [('happensAt', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1.]]
Optimal Body Condition Assignment: 
[0]
Sum of distances for optimal body condition assignment: 
1.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(inSAR(Vessel),true),I) :- 
	holdsFor(=(sarSpeed(Vessel),true),Iss),
	holdsFor(=(sarMovement(Vessel),true),Isc),
	intersect_all(list(Iss,Isc),Ii),
	intDurGreater(Ii,3600,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('inSAR', 0)], [('holdsFor', 0), ('=', 0), ('sarSpeed', 0)], [('holdsFor', 0), ('=', 0), ('sarMovement', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Iss': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 0)]], 'Isc': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('intDurGreater', 0)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]
 [1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3]
Sum of distances for optimal body condition assignment: 
4.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(loitering(Vessel),true),I) :- 
	holdsFor(=(lowSpeed(Vessel),true),Il),
	holdsFor(=(stopped(Vessel),farFromPorts),Is),
	union_all(list(Il,Is),Ils),
	holdsFor(=(withinArea(Vessel,nearCoast),true),Inc),
	holdsFor(=(anchoredOrMoored(Vessel),true),Iam),
	relative_complement_all(Ils,list(Inc,Iam),Ii),
	thresholds(loiteringTime,LoiteringTime),
	intDurGreater(Ii,LoiteringTime,I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel': [[('holdsFor', 0), ('=', 0), ('loitering', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)], [('holdsFor', 0), ('=', 0), ('anchoredOrMoored', 0)]], 'I': [[('holdsFor', 1)], [('intDurGreater', 2)]], 'Il': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Ils': [[('union_all', 1)], [('relative_complement_all', 0)]], 'Inc': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iam': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]], 'Ii': [[('relative_complement_all', 2)], [('intDurGreater', 0)]], 'LoiteringTime': [[('thresholds', 1)], [('intDurGreater', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[0 1 2 3 4 5 6 7]
Sum of distances for optimal body condition assignment: 
8.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0

Comparing rules:
 _dummy_rule :- 
	.
 and
holdsFor(=(pilotOps(Vessel1,Vessel2),true),I) :- 
	holdsFor(=(proximity(Vessel1,Vessel2),true),Ip),
	oneIsPilot(Vessel1,Vessel2),
	holdsFor(=(lowSpeed(Vessel1),true),Il1),
	holdsFor(=(lowSpeed(Vessel2),true),Il2),
	holdsFor(=(stopped(Vessel1),farFromPorts),Is1),
	holdsFor(=(stopped(Vessel2),farFromPorts),Is2),
	union_all(list(Il1,Is1),I1b),
	union_all(list(Il2,Is2),I2b),
	intersect_all(list(I1b,I2b,Ip),Ii),
	\=(Ii,list),
	holdsFor(=(withinArea(Vessel1,nearCoast),true),Iw1),
	holdsFor(=(withinArea(Vessel2,nearCoast),true),Iw2),
	relative_complement_all(Ii,list(Iw1,Iw2),I).

Var routes for the first rule: 
{}

Var routes for the second rule: 
{'Vessel1': [[('holdsFor', 0), ('=', 0), ('pilotOps', 0)], [('holdsFor', 0), ('=', 0), ('proximity', 0)], [('oneIsPilot', 0)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'Vessel2': [[('holdsFor', 0), ('=', 0), ('pilotOps', 1)], [('holdsFor', 0), ('=', 0), ('proximity', 1)], [('oneIsPilot', 1)], [('holdsFor', 0), ('=', 0), ('lowSpeed', 0)], [('holdsFor', 0), ('=', 0), ('stopped', 0)], [('holdsFor', 0), ('=', 0), ('withinArea', 0)]], 'I': [[('holdsFor', 1)], [('relative_complement_all', 2)]], 'Ip': [[('holdsFor', 1)], [('intersect_all', 0), ('list', 2)]], 'Il1': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Il2': [[('holdsFor', 1)], [('union_all', 0), ('list', 0)]], 'Is1': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'Is2': [[('holdsFor', 1)], [('union_all', 0), ('list', 1)]], 'I1b': [[('union_all', 1)], [('intersect_all', 0), ('list', 0)]], 'I2b': [[('union_all', 1)], [('intersect_all', 0), ('list', 1)]], 'Ii': [[('intersect_all', 1)], [('\\=', 0)], [('relative_complement_all', 0)]], 'Iw1': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 0)]], 'Iw2': [[('holdsFor', 1)], [('relative_complement_all', 1), ('list', 1)]]}

Distance between rule heads: 
1
Body atom distances: 
[[1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]
 [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]]
Optimal Body Condition Assignment: 
[ 0  1  2  3  4  5  6  7  8  9 10 11 12]
Sum of distances for optimal body condition assignment: 
13.0
Distance between rule bodies: 
1.0
Distance between rules: 
1.0
Similarity of rules: 
0.0
Rule distances: 
[[0.         0.66666667 0.83333333 ... 1.         1.         1.        ]
 [0.66666667 0.         0.42708333 ... 1.         1.         1.        ]
 [0.83333333 0.42708333 0.         ... 1.         1.         1.        ]
 ...
 [1.         1.         1.         ... 1.         1.         1.        ]
 [1.         1.         1.         ... 1.         1.         1.        ]
 [1.         1.         1.         ... 1.         1.         1.        ]]
Optimal Rule Assignment: 
[ 0  1  2  3  4  5  6  8  7  9 10 11 13 12 39 16 45 14 15 18 23 24 46 27
 20 28 42 17 19 29 41 33 49 21 32 26 48 22 25 30 31 34 35 36 37 38 40 43
 44 47 50]
Sum of distances for optimal rule assignment: 
35.65260416666666
Distance between event descriptions: 
0.6990706699346404
Event Description Similarity: 
0.3009293300653596
